use ::libc;
extern "C" {
    fn qsort(
        __base: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
    fn WebPSafeCalloc(nmemb: uint64_t, size: size_t) -> *mut libc::c_void;
    fn WebPSafeMalloc(nmemb: uint64_t, size: size_t) -> *mut libc::c_void;
    fn WebPSafeFree(ptr: *mut libc::c_void);
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
}
pub type size_t = libc::c_ulong;
pub type __uint8_t = libc::c_uchar;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type int32_t = __int32_t;
pub type uint8_t = __uint8_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct WebPPicture {
    pub use_argb: libc::c_int,
    pub colorspace: WebPEncCSP,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub y: *mut uint8_t,
    pub u: *mut uint8_t,
    pub v: *mut uint8_t,
    pub y_stride: libc::c_int,
    pub uv_stride: libc::c_int,
    pub a: *mut uint8_t,
    pub a_stride: libc::c_int,
    pub pad1: [uint32_t; 2],
    pub argb: *mut uint32_t,
    pub argb_stride: libc::c_int,
    pub pad2: [uint32_t; 3],
    pub writer: WebPWriterFunction,
    pub custom_ptr: *mut libc::c_void,
    pub extra_info_type: libc::c_int,
    pub extra_info: *mut uint8_t,
    pub stats: *mut WebPAuxStats,
    pub error_code: WebPEncodingError,
    pub progress_hook: WebPProgressHook,
    pub user_data: *mut libc::c_void,
    pub pad3: [uint32_t; 3],
    pub pad4: *mut uint8_t,
    pub pad5: *mut uint8_t,
    pub pad6: [uint32_t; 8],
    pub memory_: *mut libc::c_void,
    pub memory_argb_: *mut libc::c_void,
    pub pad7: [*mut libc::c_void; 2],
}
pub type WebPProgressHook = Option::<
    unsafe extern "C" fn(libc::c_int, *const WebPPicture) -> libc::c_int,
>;
pub type WebPEncodingError = libc::c_uint;
pub const VP8_ENC_ERROR_LAST: WebPEncodingError = 11;
pub const VP8_ENC_ERROR_USER_ABORT: WebPEncodingError = 10;
pub const VP8_ENC_ERROR_FILE_TOO_BIG: WebPEncodingError = 9;
pub const VP8_ENC_ERROR_BAD_WRITE: WebPEncodingError = 8;
pub const VP8_ENC_ERROR_PARTITION_OVERFLOW: WebPEncodingError = 7;
pub const VP8_ENC_ERROR_PARTITION0_OVERFLOW: WebPEncodingError = 6;
pub const VP8_ENC_ERROR_BAD_DIMENSION: WebPEncodingError = 5;
pub const VP8_ENC_ERROR_INVALID_CONFIGURATION: WebPEncodingError = 4;
pub const VP8_ENC_ERROR_NULL_PARAMETER: WebPEncodingError = 3;
pub const VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY: WebPEncodingError = 2;
pub const VP8_ENC_ERROR_OUT_OF_MEMORY: WebPEncodingError = 1;
pub const VP8_ENC_OK: WebPEncodingError = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct WebPAuxStats {
    pub coded_size: libc::c_int,
    pub PSNR: [libc::c_float; 5],
    pub block_count: [libc::c_int; 3],
    pub header_bytes: [libc::c_int; 2],
    pub residual_bytes: [[libc::c_int; 4]; 3],
    pub segment_size: [libc::c_int; 4],
    pub segment_quant: [libc::c_int; 4],
    pub segment_level: [libc::c_int; 4],
    pub alpha_data_size: libc::c_int,
    pub layer_data_size: libc::c_int,
    pub lossless_features: uint32_t,
    pub histogram_bits: libc::c_int,
    pub transform_bits: libc::c_int,
    pub cache_bits: libc::c_int,
    pub palette_size: libc::c_int,
    pub lossless_size: libc::c_int,
    pub lossless_hdr_size: libc::c_int,
    pub lossless_data_size: libc::c_int,
    pub pad: [uint32_t; 2],
}
pub type WebPWriterFunction = Option::<
    unsafe extern "C" fn(*const uint8_t, size_t, *const WebPPicture) -> libc::c_int,
>;
pub type WebPEncCSP = libc::c_uint;
pub const WEBP_CSP_ALPHA_BIT: WebPEncCSP = 4;
pub const WEBP_CSP_UV_MASK: WebPEncCSP = 3;
pub const WEBP_YUV420A: WebPEncCSP = 4;
pub const WEBP_YUV420: WebPEncCSP = 0;
pub type PaletteSorting = libc::c_uint;
pub const kPaletteSortingNum: PaletteSorting = 4;
pub const kUnusedPalette: PaletteSorting = 3;
pub const kModifiedZeng: PaletteSorting = 2;
pub const kMinimizeDelta: PaletteSorting = 1;
pub const kSortedDefault: PaletteSorting = 0;
pub type __compar_fn_t = Option::<
    unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Sum {
    pub index: uint8_t,
    pub sum: uint32_t,
}
#[inline]
unsafe extern "C" fn VP8LSubPixels(mut a: uint32_t, mut b: uint32_t) -> uint32_t {
    let alpha_and_green: uint32_t = (0xff00ff as libc::c_uint)
        .wrapping_add(a & 0xff00ff00 as libc::c_uint)
        .wrapping_sub(b & 0xff00ff00 as libc::c_uint);
    let red_and_blue: uint32_t = (0xff00ff00 as libc::c_uint)
        .wrapping_add(a & 0xff00ff as libc::c_uint)
        .wrapping_sub(b & 0xff00ff as libc::c_uint);
    return alpha_and_green & 0xff00ff00 as libc::c_uint
        | red_and_blue & 0xff00ff as libc::c_uint;
}
#[inline]
unsafe extern "C" fn WebPMemToUint32(ptr: *const uint8_t) -> uint32_t {
    let mut A: uint32_t = 0;
    memcpy(
        &mut A as *mut uint32_t as *mut libc::c_void,
        ptr as *const libc::c_void,
        ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
    );
    return A;
}
#[inline]
unsafe extern "C" fn VP8LHashPix(
    mut argb: uint32_t,
    mut shift: libc::c_int,
) -> libc::c_int {
    return (argb.wrapping_mul(kHashMul) >> shift) as libc::c_int;
}
static mut kHashMul: uint32_t = 0x1e35a7bd as libc::c_uint;
unsafe extern "C" fn PaletteCompareColorsForQsort(
    mut p1: *const libc::c_void,
    mut p2: *const libc::c_void,
) -> libc::c_int {
    let a: uint32_t = WebPMemToUint32(p1 as *mut uint8_t);
    let b: uint32_t = WebPMemToUint32(p2 as *mut uint8_t);
    return if a < b { -(1 as libc::c_int) } else { 1 as libc::c_int };
}
#[inline]
unsafe extern "C" fn PaletteComponentDistance(mut v: uint32_t) -> uint32_t {
    return if v <= 128 as libc::c_int as libc::c_uint {
        v
    } else {
        (256 as libc::c_int as libc::c_uint).wrapping_sub(v)
    };
}
#[inline]
unsafe extern "C" fn PaletteColorDistance(
    mut col1: uint32_t,
    mut col2: uint32_t,
) -> uint32_t {
    let diff: uint32_t = VP8LSubPixels(col1, col2);
    let kMoreWeightForRGBThanForAlpha: libc::c_int = 9 as libc::c_int;
    let mut score: uint32_t = 0;
    score = PaletteComponentDistance(
        diff >> 0 as libc::c_int & 0xff as libc::c_int as libc::c_uint,
    );
    score = (score as libc::c_uint)
        .wrapping_add(
            PaletteComponentDistance(
                diff >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint,
            ),
        ) as uint32_t as uint32_t;
    score = (score as libc::c_uint)
        .wrapping_add(
            PaletteComponentDistance(
                diff >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint,
            ),
        ) as uint32_t as uint32_t;
    score = (score as libc::c_uint)
        .wrapping_mul(kMoreWeightForRGBThanForAlpha as libc::c_uint) as uint32_t
        as uint32_t;
    score = (score as libc::c_uint)
        .wrapping_add(
            PaletteComponentDistance(
                diff >> 24 as libc::c_int & 0xff as libc::c_int as libc::c_uint,
            ),
        ) as uint32_t as uint32_t;
    return score;
}
#[inline]
unsafe extern "C" fn SwapColor(col1: *mut uint32_t, col2: *mut uint32_t) {
    let tmp: uint32_t = *col1;
    *col1 = *col2;
    *col2 = tmp;
}
#[no_mangle]
pub unsafe extern "C" fn SearchColorNoIdx(
    mut sorted: *const uint32_t,
    mut color: uint32_t,
    mut num_colors: libc::c_int,
) -> libc::c_int {
    let mut low: libc::c_int = 0 as libc::c_int;
    let mut hi: libc::c_int = num_colors;
    if *sorted.offset(low as isize) == color {
        return low;
    }
    loop {
        let mid: libc::c_int = low + hi >> 1 as libc::c_int;
        if *sorted.offset(mid as isize) == color {
            return mid
        } else if *sorted.offset(mid as isize) < color {
            low = mid;
        } else {
            hi = mid;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn PrepareMapToPalette(
    mut palette: *const uint32_t,
    mut num_colors: uint32_t,
    mut sorted: *mut uint32_t,
    mut idx_map: *mut uint32_t,
) {
    let mut i: uint32_t = 0;
    memcpy(
        sorted as *mut libc::c_void,
        palette as *const libc::c_void,
        (num_colors as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    qsort(
        sorted as *mut libc::c_void,
        num_colors as size_t,
        ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
        Some(
            PaletteCompareColorsForQsort
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    i = 0 as libc::c_int as uint32_t;
    while i < num_colors {
        *idx_map
            .offset(
                SearchColorNoIdx(
                    sorted as *const uint32_t,
                    *palette.offset(i as isize),
                    num_colors as libc::c_int,
                ) as isize,
            ) = i;
        i = i.wrapping_add(1);
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn GetColorPalette(
    pic: *const WebPPicture,
    palette: *mut uint32_t,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut num_colors: libc::c_int = 0 as libc::c_int;
    let mut in_use: [uint8_t; 1024] = [
        0 as libc::c_int as uint8_t,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut colors: [uint32_t; 1024] = [
        0 as libc::c_int as uint32_t,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut argb: *const uint32_t = (*pic).argb;
    let width: libc::c_int = (*pic).width;
    let height: libc::c_int = (*pic).height;
    let mut last_pix: uint32_t = !*argb.offset(0 as libc::c_int as isize);
    y = 0 as libc::c_int;
    while y < height {
        x = 0 as libc::c_int;
        while x < width {
            let mut key: libc::c_int = 0;
            if !(*argb.offset(x as isize) == last_pix) {
                last_pix = *argb.offset(x as isize);
                key = VP8LHashPix(last_pix, 22 as libc::c_int);
                loop {
                    if in_use[key as usize] == 0 {
                        colors[key as usize] = last_pix;
                        in_use[key as usize] = 1 as libc::c_int as uint8_t;
                        num_colors += 1;
                        num_colors;
                        if num_colors > 256 as libc::c_int {
                            return 256 as libc::c_int + 1 as libc::c_int;
                        }
                        break;
                    } else {
                        if colors[key as usize] == last_pix {
                            break;
                        }
                        key += 1;
                        key;
                        key &= 256 as libc::c_int * 4 as libc::c_int - 1 as libc::c_int;
                    }
                }
            }
            x += 1;
            x;
        }
        argb = argb.offset((*pic).argb_stride as isize);
        y += 1;
        y;
    }
    if !palette.is_null() {
        num_colors = 0 as libc::c_int;
        i = 0 as libc::c_int;
        while i < 256 as libc::c_int * 4 as libc::c_int {
            if in_use[i as usize] != 0 {
                *palette.offset(num_colors as isize) = colors[i as usize];
                num_colors += 1;
                num_colors;
            }
            i += 1;
            i;
        }
        qsort(
            palette as *mut libc::c_void,
            num_colors as size_t,
            ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
            Some(
                PaletteCompareColorsForQsort
                    as unsafe extern "C" fn(
                        *const libc::c_void,
                        *const libc::c_void,
                    ) -> libc::c_int,
            ),
        );
    }
    return num_colors;
}
unsafe extern "C" fn PaletteHasNonMonotonousDeltas(
    palette: *const uint32_t,
    mut num_colors: libc::c_int,
) -> libc::c_int {
    let mut predict: uint32_t = 0 as libc::c_int as uint32_t;
    let mut i: libc::c_int = 0;
    let mut sign_found: uint8_t = 0 as libc::c_int as uint8_t;
    i = 0 as libc::c_int;
    while i < num_colors {
        let diff: uint32_t = VP8LSubPixels(*palette.offset(i as isize), predict);
        let rd: uint8_t = (diff >> 16 as libc::c_int
            & 0xff as libc::c_int as libc::c_uint) as uint8_t;
        let gd: uint8_t = (diff >> 8 as libc::c_int
            & 0xff as libc::c_int as libc::c_uint) as uint8_t;
        let bd: uint8_t = (diff >> 0 as libc::c_int
            & 0xff as libc::c_int as libc::c_uint) as uint8_t;
        if rd as libc::c_int != 0 as libc::c_int {
            sign_found = (sign_found as libc::c_int
                | if (rd as libc::c_int) < 0x80 as libc::c_int {
                    1 as libc::c_int
                } else {
                    2 as libc::c_int
                }) as uint8_t;
        }
        if gd as libc::c_int != 0 as libc::c_int {
            sign_found = (sign_found as libc::c_int
                | if (gd as libc::c_int) < 0x80 as libc::c_int {
                    8 as libc::c_int
                } else {
                    16 as libc::c_int
                }) as uint8_t;
        }
        if bd as libc::c_int != 0 as libc::c_int {
            sign_found = (sign_found as libc::c_int
                | if (bd as libc::c_int) < 0x80 as libc::c_int {
                    64 as libc::c_int
                } else {
                    128 as libc::c_int
                }) as uint8_t;
        }
        predict = *palette.offset(i as isize);
        i += 1;
        i;
    }
    return (sign_found as libc::c_int & (sign_found as libc::c_int) << 1 as libc::c_int
        != 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn PaletteSortMinimizeDeltas(
    palette_sorted: *const uint32_t,
    mut num_colors: libc::c_int,
    palette: *mut uint32_t,
) {
    let mut predict: uint32_t = 0 as libc::c_int as uint32_t;
    let mut i: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    memcpy(
        palette as *mut libc::c_void,
        palette_sorted as *const libc::c_void,
        (num_colors as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    if PaletteHasNonMonotonousDeltas(palette_sorted, num_colors) == 0 {
        return;
    }
    i = 0 as libc::c_int;
    while i < num_colors {
        let mut best_ix: libc::c_int = i;
        let mut best_score: uint32_t = !(0 as libc::c_uint);
        k = i;
        while k < num_colors {
            let cur_score: uint32_t = PaletteColorDistance(
                *palette.offset(k as isize),
                predict,
            );
            if best_score > cur_score {
                best_score = cur_score;
                best_ix = k;
            }
            k += 1;
            k;
        }
        SwapColor(
            &mut *palette.offset(best_ix as isize),
            &mut *palette.offset(i as isize),
        );
        predict = *palette.offset(i as isize);
        i += 1;
        i;
    }
}
unsafe extern "C" fn CoOccurrenceFindMax(
    cooccurrence: *const uint32_t,
    mut num_colors: uint32_t,
    c1: *mut uint8_t,
    c2: *mut uint8_t,
) {
    let mut best_sum: uint32_t = 0 as libc::c_uint;
    let mut i: uint32_t = 0;
    let mut j: uint32_t = 0;
    let mut best_cooccurrence: uint32_t = 0;
    *c1 = 0 as libc::c_uint as uint8_t;
    i = 0 as libc::c_int as uint32_t;
    while i < num_colors {
        let mut sum: uint32_t = 0 as libc::c_int as uint32_t;
        j = 0 as libc::c_int as uint32_t;
        while j < num_colors {
            sum = (sum as libc::c_uint)
                .wrapping_add(
                    *cooccurrence
                        .offset(i.wrapping_mul(num_colors).wrapping_add(j) as isize),
                ) as uint32_t as uint32_t;
            j = j.wrapping_add(1);
            j;
        }
        if sum > best_sum {
            best_sum = sum;
            *c1 = i as uint8_t;
        }
        i = i.wrapping_add(1);
        i;
    }
    *c2 = 0 as libc::c_uint as uint8_t;
    best_cooccurrence = 0 as libc::c_uint;
    i = 0 as libc::c_int as uint32_t;
    while i < num_colors {
        if *cooccurrence
            .offset(
                (*c1 as libc::c_uint).wrapping_mul(num_colors).wrapping_add(i) as isize,
            ) > best_cooccurrence
        {
            best_cooccurrence = *cooccurrence
                .offset(
                    (*c1 as libc::c_uint).wrapping_mul(num_colors).wrapping_add(i)
                        as isize,
                );
            *c2 = i as uint8_t;
        }
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn CoOccurrenceBuild(
    pic: *const WebPPicture,
    palette: *const uint32_t,
    mut num_colors: uint32_t,
    mut cooccurrence: *mut uint32_t,
) -> libc::c_int {
    let mut lines: *mut uint32_t = 0 as *mut uint32_t;
    let mut line_top: *mut uint32_t = 0 as *mut uint32_t;
    let mut line_current: *mut uint32_t = 0 as *mut uint32_t;
    let mut line_tmp: *mut uint32_t = 0 as *mut uint32_t;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut src: *const uint32_t = (*pic).argb;
    let mut prev_pix: uint32_t = !*src.offset(0 as libc::c_int as isize);
    let mut prev_idx: uint32_t = 0 as libc::c_uint;
    let mut idx_map: [uint32_t; 256] = [
        0 as libc::c_int as uint32_t,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut palette_sorted: [uint32_t; 256] = [0; 256];
    lines = WebPSafeMalloc(
        (2 as libc::c_int * (*pic).width) as uint64_t,
        ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
    ) as *mut uint32_t;
    if lines.is_null() {
        return 0 as libc::c_int;
    }
    line_top = &mut *lines.offset(0 as libc::c_int as isize) as *mut uint32_t;
    line_current = &mut *lines.offset((*pic).width as isize) as *mut uint32_t;
    PrepareMapToPalette(
        palette,
        num_colors,
        palette_sorted.as_mut_ptr(),
        idx_map.as_mut_ptr(),
    );
    y = 0 as libc::c_int;
    while y < (*pic).height {
        x = 0 as libc::c_int;
        while x < (*pic).width {
            let pix: uint32_t = *src.offset(x as isize);
            if pix != prev_pix {
                prev_idx = idx_map[SearchColorNoIdx(
                    palette_sorted.as_mut_ptr() as *const uint32_t,
                    pix,
                    num_colors as libc::c_int,
                ) as usize];
                prev_pix = pix;
            }
            *line_current.offset(x as isize) = prev_idx;
            if x > 0 as libc::c_int
                && prev_idx != *line_current.offset((x - 1 as libc::c_int) as isize)
            {
                let left_idx: uint32_t = *line_current
                    .offset((x - 1 as libc::c_int) as isize);
                let ref mut fresh0 = *cooccurrence
                    .offset(
                        prev_idx.wrapping_mul(num_colors).wrapping_add(left_idx) as isize,
                    );
                *fresh0 = (*fresh0).wrapping_add(1);
                *fresh0;
                let ref mut fresh1 = *cooccurrence
                    .offset(
                        left_idx.wrapping_mul(num_colors).wrapping_add(prev_idx) as isize,
                    );
                *fresh1 = (*fresh1).wrapping_add(1);
                *fresh1;
            }
            if y > 0 as libc::c_int && prev_idx != *line_top.offset(x as isize) {
                let top_idx: uint32_t = *line_top.offset(x as isize);
                let ref mut fresh2 = *cooccurrence
                    .offset(
                        prev_idx.wrapping_mul(num_colors).wrapping_add(top_idx) as isize,
                    );
                *fresh2 = (*fresh2).wrapping_add(1);
                *fresh2;
                let ref mut fresh3 = *cooccurrence
                    .offset(
                        top_idx.wrapping_mul(num_colors).wrapping_add(prev_idx) as isize,
                    );
                *fresh3 = (*fresh3).wrapping_add(1);
                *fresh3;
            }
            x += 1;
            x;
        }
        line_tmp = line_top;
        line_top = line_current;
        line_current = line_tmp;
        src = src.offset((*pic).argb_stride as isize);
        y += 1;
        y;
    }
    WebPSafeFree(lines as *mut libc::c_void);
    return 1 as libc::c_int;
}
unsafe extern "C" fn PaletteSortModifiedZeng(
    pic: *const WebPPicture,
    palette_in: *const uint32_t,
    mut num_colors: uint32_t,
    palette: *mut uint32_t,
) -> libc::c_int {
    let mut i: uint32_t = 0;
    let mut j: uint32_t = 0;
    let mut ind: uint32_t = 0;
    let mut remapping: [uint8_t; 256] = [0; 256];
    let mut cooccurrence: *mut uint32_t = 0 as *mut uint32_t;
    let mut sums: [Sum; 256] = [Sum { index: 0, sum: 0 }; 256];
    let mut first: uint32_t = 0;
    let mut last: uint32_t = 0;
    let mut num_sums: uint32_t = 0;
    if num_colors <= 1 as libc::c_int as libc::c_uint {
        return 1 as libc::c_int;
    }
    cooccurrence = WebPSafeCalloc(
        num_colors.wrapping_mul(num_colors) as uint64_t,
        ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
    ) as *mut uint32_t;
    if cooccurrence.is_null() {
        return 0 as libc::c_int;
    }
    if CoOccurrenceBuild(pic, palette_in, num_colors, cooccurrence) == 0 {
        WebPSafeFree(cooccurrence as *mut libc::c_void);
        return 0 as libc::c_int;
    }
    CoOccurrenceFindMax(
        cooccurrence,
        num_colors,
        &mut *remapping.as_mut_ptr().offset(0 as libc::c_int as isize),
        &mut *remapping.as_mut_ptr().offset(1 as libc::c_int as isize),
    );
    first = 0 as libc::c_int as uint32_t;
    last = 1 as libc::c_int as uint32_t;
    num_sums = num_colors.wrapping_sub(2 as libc::c_int as libc::c_uint);
    if num_sums > 0 as libc::c_int as libc::c_uint {
        let mut best_sum: *mut Sum = &mut *sums
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize) as *mut Sum;
        (*best_sum).index = 0 as libc::c_uint as uint8_t;
        (*best_sum).sum = 0 as libc::c_uint;
        i = 0 as libc::c_int as uint32_t;
        j = 0 as libc::c_int as uint32_t;
        while i < num_colors {
            if !(i == remapping[0 as libc::c_int as usize] as libc::c_uint
                || i == remapping[1 as libc::c_int as usize] as libc::c_uint)
            {
                sums[j as usize].index = i as uint8_t;
                sums[j as usize]
                    .sum = (*cooccurrence
                    .offset(
                        i
                            .wrapping_mul(num_colors)
                            .wrapping_add(
                                remapping[0 as libc::c_int as usize] as libc::c_uint,
                            ) as isize,
                    ))
                    .wrapping_add(
                        *cooccurrence
                            .offset(
                                i
                                    .wrapping_mul(num_colors)
                                    .wrapping_add(
                                        remapping[1 as libc::c_int as usize] as libc::c_uint,
                                    ) as isize,
                            ),
                    );
                if sums[j as usize].sum > (*best_sum).sum {
                    best_sum = &mut *sums.as_mut_ptr().offset(j as isize) as *mut Sum;
                }
                j = j.wrapping_add(1);
                j;
            }
            i = i.wrapping_add(1);
            i;
        }
        while num_sums > 0 as libc::c_int as libc::c_uint {
            let best_index: uint8_t = (*best_sum).index;
            let mut delta: int32_t = 0 as libc::c_int;
            let n: int32_t = num_colors.wrapping_sub(num_sums) as int32_t;
            ind = first;
            j = 0 as libc::c_int as uint32_t;
            while ind.wrapping_add(j).wrapping_rem(num_colors)
                != last.wrapping_add(1 as libc::c_int as libc::c_uint)
            {
                let l_j: uint16_t = remapping[ind
                    .wrapping_add(j)
                    .wrapping_rem(num_colors) as usize] as uint16_t;
                delta
                    += (n - 1 as libc::c_int - 2 as libc::c_int * j as int32_t)
                        * *cooccurrence
                            .offset(
                                (best_index as libc::c_uint)
                                    .wrapping_mul(num_colors)
                                    .wrapping_add(l_j as libc::c_uint) as isize,
                            ) as int32_t;
                j = j.wrapping_add(1);
                j;
            }
            if delta > 0 as libc::c_int {
                first = if first == 0 as libc::c_int as libc::c_uint {
                    num_colors.wrapping_sub(1 as libc::c_int as libc::c_uint)
                } else {
                    first.wrapping_sub(1 as libc::c_int as libc::c_uint)
                };
                remapping[first as usize] = best_index;
            } else {
                last = last.wrapping_add(1);
                last;
                remapping[last as usize] = best_index;
            }
            *best_sum = sums[num_sums.wrapping_sub(1 as libc::c_int as libc::c_uint)
                as usize];
            num_sums = num_sums.wrapping_sub(1);
            num_sums;
            best_sum = &mut *sums.as_mut_ptr().offset(0 as libc::c_int as isize)
                as *mut Sum;
            i = 0 as libc::c_int as uint32_t;
            while i < num_sums {
                sums[i as usize]
                    .sum = (sums[i as usize].sum as libc::c_uint)
                    .wrapping_add(
                        *cooccurrence
                            .offset(
                                (best_index as libc::c_uint)
                                    .wrapping_mul(num_colors)
                                    .wrapping_add(sums[i as usize].index as libc::c_uint)
                                    as isize,
                            ),
                    ) as uint32_t as uint32_t;
                if sums[i as usize].sum > (*best_sum).sum {
                    best_sum = &mut *sums.as_mut_ptr().offset(i as isize) as *mut Sum;
                }
                i = i.wrapping_add(1);
                i;
            }
        }
    }
    WebPSafeFree(cooccurrence as *mut libc::c_void);
    i = 0 as libc::c_int as uint32_t;
    while i < num_colors {
        *palette
            .offset(
                i as isize,
            ) = *palette_in
            .offset(
                remapping[first.wrapping_add(i).wrapping_rem(num_colors) as usize]
                    as isize,
            );
        i = i.wrapping_add(1);
        i;
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn PaletteSort(
    mut method: PaletteSorting,
    pic: *const WebPPicture,
    palette_sorted: *const uint32_t,
    mut num_colors: uint32_t,
    palette: *mut uint32_t,
) -> libc::c_int {
    match method as libc::c_uint {
        0 => {
            memcpy(
                palette as *mut libc::c_void,
                palette_sorted as *const libc::c_void,
                (num_colors as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
            );
            return 1 as libc::c_int;
        }
        1 => {
            PaletteSortMinimizeDeltas(
                palette_sorted,
                num_colors as libc::c_int,
                palette,
            );
            return 1 as libc::c_int;
        }
        2 => return PaletteSortModifiedZeng(pic, palette_sorted, num_colors, palette),
        3 | 4 | _ => {}
    }
    return 0 as libc::c_int;
}
